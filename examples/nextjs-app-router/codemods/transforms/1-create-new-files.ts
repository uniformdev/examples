import * as fs from 'fs';
import * as path from 'path';
import type { ResolvedConfig } from '../types/config';

const flattenParametersContent = `import { ComponentParameter } from '@uniformdev/canvas-next-rsc-v2/component';

const emptyObject = {};

type FlattenedParameters<T> = {
  [K in keyof T]: T[K] extends Uniform.Asset[] ? Uniform.Asset[] : T[K];
};

const mapUniformContentFields = (fields: Record<string, any>) => {
  return Object.keys(fields).reduce((acc, key) => {
    acc[key] = fields[key]?.value ?? fields[key];
    return acc;
  }, {} as Record<string, any>);
};

const mapUniformContentEntryFields = (entry: any) => {
  if (!entry?.fields) return entry;
  return {
    ...mapUniformContentFields(entry.fields),
    _id: entry._id,
  };
};

const flattenParameters = <T extends Record<string, any>>(
  parameters: Record<string, ComponentParameter<any>>
): FlattenedParameters<T> => {
  if (!parameters) return emptyObject as FlattenedParameters<T>;

  const data = Object.keys(parameters).reduce((acc, key) => {
    const parameter = parameters[key];

    if (parameter.type === '$block') {
      acc[key] = parameter.value.map((block: any) => ({
        type: block.type,
        id: block._id,
        ...mapUniformContentFields(block.fields),
      }));
      return acc;
    }

    if (parameter.type === 'asset' && Array.isArray(parameter.value)) {
      acc[key] = parameter.value.map((asset: any) => mapUniformContentFields(asset.fields));
      return acc;
    }

    if (parameter.type === 'contentReference') {
      if (Array.isArray(parameter.value)) {
        acc[key] = parameter.value.map((reference: any) => mapUniformContentEntryFields(reference.entry));
      } else {
        acc[key] = mapUniformContentEntryFields(parameter.value.entry);
      }
      return acc;
    }

    acc[key] = parameter.value;
    return acc;
  }, {} as any);

  return data as FlattenedParameters<T>; 
};

export default flattenParameters;
`;

const proxyContent = `import { uniformMiddleware } from "@uniformdev/canvas-next-rsc-v2/middleware";

export default uniformMiddleware({
  // Uncomment if you want to rewrite the request path to the default language
  // rewriteRequestPath: async ({ url }) => ({
  //   path: \`/en\${url.pathname}\`,
  // }), 
});`;

const resolveRouteFromRoutePathContent = `import { CANVAS_DRAFT_STATE, CANVAS_PUBLISHED_STATE } from '@uniformdev/canvas';
import { serializeEvaluationResult } from '@uniformdev/canvas-next-rsc-shared-v2';
import { resolveRouteFromCode } from '@uniformdev/canvas-next-rsc-v2';

const resolveRouteFromRoutePath = async (routePath: string, isPreviewMode: boolean = false) => {
  const code = serializeEvaluationResult({
    payload: {
      compositionState: isPreviewMode ? CANVAS_DRAFT_STATE : CANVAS_PUBLISHED_STATE,
      routePath,
      keys: undefined,
      components: {},
      releaseId: undefined,
    },
  });

  return await resolveRouteFromCode({
    params: Promise.resolve({
      code,
    }),
  });
};

export default resolveRouteFromRoutePath;
`;

const layoutContent = `import { UniformContext } from "@uniformdev/canvas-next-rsc-v2";
import type { Metadata } from "next";
import { Suspense } from "react";

import "./globals.css";

export const metadata: Metadata = {
  title: "Create Next App",
  description: "Generated by create next app",
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="en">
      <body>
        {children}

        <Suspense>
          <UniformContext />
        </Suspense>
      </body>
    </html>
  );
}`;

const previewRouteContent = `import {
  createPreviewGETRouteHandler,
  createPreviewPOSTRouteHandler,
  createPreviewOPTIONSRouteHandler,
} from "@uniformdev/canvas-next-rsc-v2/handler";

export const GET = createPreviewGETRouteHandler({
  resolveFullPath: ({ path }) => (path ? path : "/playground"),
});
export const POST = createPreviewPOSTRouteHandler();
export const OPTIONS = createPreviewOPTIONSRouteHandler();
`;

const resolveComponentContent = `import { FC } from "react";
import {
  ResolveComponentFunction,
  ResolveComponentResult,
} from "@uniformdev/canvas-next-rsc-v2";
import * as mappings from "./mappings";
import { ResolveComponentResultWithType } from "./models";

export const DefaultNotFoundComponent: FC<Uniform.ComponentProps<unknown>> = ({
  type,
}) => {
  return (
    <div>
      Component not found: <b>{type}</b>
    </div>
  );
};

export const resolveComponent: ResolveComponentFunction = ({ component }) => {
  let result: ResolveComponentResult = {
    component: DefaultNotFoundComponent,
  };

  const keys = Object.keys(mappings);

  for (let i = 0; i < keys.length; i++) {
    const key = keys[i]!;

    const mapping = (mappings as any)[key] as
      | ResolveComponentResultWithType
      | undefined;

    if (mapping?.type === component.type) {
      result = mapping;
      break;
    }
  }

  return result;
};
`;

function buildPageContent(resolveComponentImport: string): string {
  return `import {
  resolveRouteFromCode,
  UniformComposition,
  UniformPageParameters,
  createUniformStaticParams,
} from "@uniformdev/canvas-next-rsc-v2";
import { notFound } from "next/navigation";

import { resolveComponent } from "${resolveComponentImport}";

export const generateStaticParams = async () => {
  return createUniformStaticParams({
    paths: ["/"],
  });
};

export default async function UniformPage(props: UniformPageParameters) {
  const result = await resolveRouteFromCode(props);

  if (!result.route) {
    notFound();
  }

  return <UniformComposition {...result} resolveComponent={resolveComponent} />;
}
`;
}

function buildPlaygroundPageContent(resolveComponentImport: string): string {
  return `import {
  resolvePlaygroundRoute,
  UniformPageParameters,
  UniformPlayground,
} from "@uniformdev/canvas-next-rsc-v2";
import { resolveComponent } from "${resolveComponentImport}";

export default async function PlaygroundPage(props: UniformPageParameters) {
  const result = await resolvePlaygroundRoute(props);
  return (
    <UniformPlayground route={result} resolveComponent={resolveComponent} />
  );
}
`;
}

function buildNotFoundPageContent(resolveComponentImport: string, resolveRouteImport: string): string {
  return `import { notFound } from 'next/navigation';
import { UniformComposition } from '@uniformdev/canvas-next-rsc-v2';
import resolveRouteFromRoutePath from '${resolveRouteImport}';
import { resolveComponent } from '${resolveComponentImport}';

const ROUTE_PATH = \`/en/404\`;

export default async function NotFound() {
  const result = await resolveRouteFromRoutePath(ROUTE_PATH);

  if (!result.route) {
    notFound();
  }

  return <UniformComposition {...result} resolveComponent={resolveComponent} />;
}

export const dynamic = 'force-dynamic';
`;
}

type GeneratedFileDefinition = {
  label: string;
  getPath: (config: ResolvedConfig) => string;
  getContent: (config: ResolvedConfig, targetPath: string) => string;
  beforeWrite?: (config: ResolvedConfig, targetPath: string) => void;
  skipDefaultBackup?: boolean;
};

function buildUniformServerConfigContent(targetPath: string): string {
  const extension = path.extname(targetPath).toLowerCase();

  const configBody = `{
  defaultConsent: true,
  experimental: {
    quirkSerialization: true,
    middlewareRuntimeCache: true,
  },
  playgroundPath: "/playground",
}`;

  if (extension === '.ts') {
    return `import type { UniformServerConfig } from "@uniformdev/canvas-next-rsc-v2/config";

const config: UniformServerConfig = ${configBody};

export default config;
`;
  }

  if (extension === '.mjs') {
    return `const config = ${configBody};

export default config;
`;
  }

  // default to CommonJS
  return `/** @type {import('@uniformdev/canvas-next-rsc-v2/config').UniformServerConfig} */
const config = ${configBody};

module.exports = config;
`;
}

const GENERATED_FILES: GeneratedFileDefinition[] = [
  {
    label: 'flattenParameters',
    getPath: config => config.paths.flattenParametersOutput,
    getContent: () => flattenParametersContent,
  },
  {
    label: 'Uniform page route',
    getPath: config => config.paths.pageOutput,
    getContent: config => buildPageContent(config.paths.resolveComponentImport),
  },
  {
    label: 'Uniform playground page',
    getPath: config => config.paths.playgroundPageOutput,
    getContent: config => buildPlaygroundPageContent(config.paths.resolveComponentImport),
  },
  {
    label: 'proxy entry point',
    getPath: config => config.paths.proxyOutput,
    getContent: () => proxyContent,
  },
  {
    label: 'resolveRouteFromRoutePath utility',
    getPath: config => config.paths.resolveRouteFromRoutePathOutput,
    getContent: () => resolveRouteFromRoutePathContent,
  },
  {
    label: 'not-found page',
    getPath: config => config.paths.notFoundPageOutput,
    getContent: config =>
      buildNotFoundPageContent(config.paths.resolveComponentImport, config.paths.resolveRouteFromRoutePathImport),
  },
  {
    label: 'uniform server config',
    getPath: config => config.paths.uniformServerConfigOutput,
    getContent: (_, targetPath) => buildUniformServerConfigContent(targetPath),
    beforeWrite: (config, targetPath) => {
      const backupPath = createBackup(targetPath);
      if (backupPath) {
        console.log(`✓ Created backup of existing uniform server config at ${getRelativePath(config, backupPath)}`);
      }

      const extension = path.extname(targetPath).toLowerCase();
      if (extension === '.ts') {
        const legacyJsPath = targetPath.replace(/\.ts$/, '.js');
        if (fs.existsSync(legacyJsPath)) {
          const legacyBackup = createBackup(legacyJsPath, {
            rename: true,
          });
          if (legacyBackup) {
            console.log(`✓ Moved legacy uniform.server.config.js to ${getRelativePath(config, legacyBackup)}`);
          }
        }
      }
    },
    skipDefaultBackup: true,
  },
  {
    label: 'root layout',
    getPath: config => config.paths.layoutOutput,
    getContent: () => layoutContent,
  },
  {
    label: 'preview route handler',
    getPath: config => config.paths.previewRouteOutput,
    getContent: () => previewRouteContent,
  },
  {
    label: 'resolveComponent helper',
    getPath: config => config.paths.resolveComponentOutput,
    getContent: () => resolveComponentContent,
  },
];

function ensureDirectory(filePath: string): void {
  const targetDir = path.dirname(filePath);
  if (!fs.existsSync(targetDir)) {
    fs.mkdirSync(targetDir, { recursive: true });
  }
}

function getRelativePath(config: ResolvedConfig, absolutePath: string): string {
  return path.relative(config.projectRoot, absolutePath) || '.';
}

function createBackup(filePath: string, options: { rename?: boolean } = {}): string | null {
  if (!fs.existsSync(filePath)) {
    return null;
  }

  const { rename = false } = options;
  const baseBackupPath = `${filePath}.backup`;
  let candidate = baseBackupPath;
  let counter = 1;

  while (fs.existsSync(candidate)) {
    candidate = `${baseBackupPath}.${counter}`;
    counter += 1;
  }

  if (rename) {
    fs.renameSync(filePath, candidate);
  } else {
    fs.copyFileSync(filePath, candidate);
  }

  return candidate;
}

function writeFileWithBackup(
  config: ResolvedConfig,
  targetPath: string,
  content: string,
  options: { label?: string; skipBackup?: boolean } = {}
): void {
  ensureDirectory(targetPath);
  let backupPath: string | null = null;
  if (!options.skipBackup) {
    backupPath = createBackup(targetPath);
    if (backupPath) {
      console.log(
        `✓ Created backup of existing ${options.label ?? path.basename(targetPath)} at ${getRelativePath(
          config,
          backupPath
        )}`
      );
    }
  }
  fs.writeFileSync(targetPath, content, 'utf8');
  console.log(`✓ Created ${options.label ?? path.basename(targetPath)} at ${getRelativePath(config, targetPath)}`);
}

function writeGeneratedFile(config: ResolvedConfig, definition: GeneratedFileDefinition): void {
  const targetPath = definition.getPath(config);
  ensureDirectory(targetPath);

  if (definition.beforeWrite) {
    definition.beforeWrite(config, targetPath);
  }

  const content = definition.getContent(config, targetPath);

  writeFileWithBackup(config, targetPath, content, {
    label: definition.label,
    skipBackup: definition.skipDefaultBackup,
  });
}

function createAllFiles(config: ResolvedConfig): void {
  GENERATED_FILES.forEach(definition => {
    writeGeneratedFile(config, definition);
  });
}

// If run directly (for backwards compatibility, load config)
if (require.main === module) {
  const { loadAndResolveConfig, getProjectRoot } = require('../utils/config-loader');
  try {
    const projectRoot = getProjectRoot();
    const config = loadAndResolveConfig(projectRoot);
    createAllFiles(config);
  } catch (error) {
    console.error('Error:', (error as Error).message);
    process.exit(1);
  }
}

export default createAllFiles;
